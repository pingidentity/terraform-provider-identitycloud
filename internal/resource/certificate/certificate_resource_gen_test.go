// Code generated by ping-terraform-plugin-framework-generator

package certificate_test

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"os"
	"strings"
	"testing"

	"github.com/hashicorp/terraform-plugin-framework/providerserver"
	"github.com/hashicorp/terraform-plugin-go/tfprotov6"
	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
	"github.com/hashicorp/terraform-plugin-testing/terraform"
	"github.com/pingidentity/terraform-provider-identitycloud/internal/acctest"
	"github.com/pingidentity/terraform-provider-identitycloud/internal/provider"
	"github.com/pingidentity/terraform-provider-identitycloud/internal/utils"
)

const certificateId = "certificateId"

var certificateTestServerUrl *string

func TestAccCertificate_RemovalDrift(t *testing.T) {
	//TODO remove this skip when this test is ready
	t.SkipNow()
	if strings.ToLower(os.Getenv("PINGAIC_TF_TEST_MOCK_SERVICE")) == "true" {
		testServer := certificate_MockHttpServer()
		certificateTestServerUrl = utils.Pointer(testServer.URL)
		os.Setenv("PINGAIC_TF_TEST_OVERRIDE_URL", testServer.URL)
		defer testServer.Close()
	}
	resource.Test(t, resource.TestCase{
		PreCheck: func() { acctest.ConfigurationPreCheck(t) },
		ProtoV6ProviderFactories: map[string]func() (tfprotov6.ProviderServer, error){
			"identitycloud": providerserver.NewProtocol6WithError(provider.NewTestProvider()),
		},
		CheckDestroy: certificate_CheckDestroy,
		Steps: []resource.TestStep{
			{
				// Create the resource with a minimal model
				Config: certificate_MinimalHCL(),
			},
			{
				// Delete the resource on the service, outside of terraform, verify that a non-empty plan is generated
				PreConfig: func() {
					certificate_Delete(t)
				},
				RefreshState:       true,
				ExpectNonEmptyPlan: true,
			},
		},
	})
}

func TestAccCertificate_MinimalMaximal(t *testing.T) {
	//TODO remove this skip when this test is ready
	t.SkipNow()
	if strings.ToLower(os.Getenv("PINGAIC_TF_TEST_MOCK_SERVICE")) == "true" {
		testServer := certificate_MockHttpServer()
		certificateTestServerUrl = utils.Pointer(testServer.URL)
		os.Setenv("PINGAIC_TF_TEST_OVERRIDE_URL", testServer.URL)
		defer testServer.Close()
	}
	resource.Test(t, resource.TestCase{
		PreCheck: func() { acctest.ConfigurationPreCheck(t) },
		ProtoV6ProviderFactories: map[string]func() (tfprotov6.ProviderServer, error){
			"identitycloud": providerserver.NewProtocol6WithError(provider.NewTestProvider()),
		},
		CheckDestroy: certificate_CheckDestroy,
		Steps: []resource.TestStep{
			{
				// Create the resource with a minimal model
				Config: certificate_MinimalHCL(),
				Check:  certificate_CheckComputedValuesMinimal(),
			},
			{
				// Delete the minimal model
				Config:  certificate_MinimalHCL(),
				Destroy: true,
			},
			{
				// Re-create with a complete model
				Config: certificate_CompleteHCL(),
				Check:  certificate_CheckComputedValuesComplete(),
			},
			{
				// Back to minimal model
				Config: certificate_MinimalHCL(),
				Check:  certificate_CheckComputedValuesMinimal(),
			},
			{
				// Back to complete model
				Config: certificate_CompleteHCL(),
				Check:  certificate_CheckComputedValuesComplete(),
			},
		},
	})
}

// Minimal HCL with only required values set
// TODO update with realistic cert and private key when testing with the real service
func certificate_MinimalHCL() string {
	return `
resource "identitycloud_certificate" "example" {
  certificate = "certexample"
  private_key = "keyexample"
}
`
}

// Maximal HCL with all values set where possible
func certificate_CompleteHCL() string {
	return `
resource "identitycloud_certificate" "example" {
  active = false
  certificate = "certexample"
  private_key = "keyexample"
}
`
}

// Validate any computed values when applying minimal HCL
// TODO verify expected values with real service
func certificate_CheckComputedValuesMinimal() resource.TestCheckFunc {
	return resource.ComposeTestCheckFunc(
		resource.TestCheckResourceAttr("identitycloud_certificate.example", "id", certificateId),
		resource.TestCheckResourceAttr("identitycloud_certificate.example", "active", "true"),
		resource.TestCheckResourceAttr("identitycloud_certificate.example", "expire_time", "2029-01-01T00:00:00Z"),
		resource.TestCheckResourceAttr("identitycloud_certificate.example", "issuer", "cn=example"),
		resource.TestCheckResourceAttr("identitycloud_certificate.example", "live", "false"),
		resource.TestCheckResourceAttr("identitycloud_certificate.example", "subject", "cn=subject"),
		resource.TestCheckResourceAttr("identitycloud_certificate.example", "subject_alternative_names.#", "1"),
		resource.TestCheckResourceAttr("identitycloud_certificate.example", "subject_alternative_names.0", "cn=altsubject"),
		resource.TestCheckResourceAttr("identitycloud_certificate.example", "valid_from_time", "2024-01-01T00:00:00Z"),
	)
}

// Validate any computed values when applying complete HCL
func certificate_CheckComputedValuesComplete() resource.TestCheckFunc {
	return resource.ComposeTestCheckFunc(
		resource.TestCheckResourceAttr("identitycloud_certificate.example", "id", certificateId),
		resource.TestCheckResourceAttr("identitycloud_certificate.example", "expire_time", "2029-01-01T00:00:00Z"),
		resource.TestCheckResourceAttr("identitycloud_certificate.example", "issuer", "cn=example"),
		resource.TestCheckResourceAttr("identitycloud_certificate.example", "live", "false"),
		resource.TestCheckResourceAttr("identitycloud_certificate.example", "subject", "cn=subject"),
		resource.TestCheckResourceAttr("identitycloud_certificate.example", "subject_alternative_names.#", "1"),
		resource.TestCheckResourceAttr("identitycloud_certificate.example", "subject_alternative_names.0", "cn=altsubject"),
		resource.TestCheckResourceAttr("identitycloud_certificate.example", "valid_from_time", "2024-01-01T00:00:00Z"),
	)
}

// Delete the resource
func certificate_Delete(t *testing.T) {
	testClient := acctest.Client(certificateTestServerUrl)
	_, err := testClient.CertificatesAPI.DeleteCertificateByID(acctest.AuthContext(), certificateId).Execute()
	if err != nil {
		t.Fatalf("Failed to delete config: %v", err)
	}
}

// Test that any objects created by the test are destroyed
func certificate_CheckDestroy(s *terraform.State) error {
	testClient := acctest.Client(certificateTestServerUrl)
	_, err := testClient.CertificatesAPI.DeleteCertificateByID(acctest.AuthContext(), certificateId).Execute()
	if err == nil {
		return fmt.Errorf("certificate still exists after tests. Expected it to be destroyed")
	}
	return nil
}

type certificate struct {
	Active                  bool     `json:"active"`
	Certificate             string   `json:"certificate"`
	PrivateKey              string   `json:"privateKey"`
	ExpireTime              string   `json:"expireTime"`
	Id                      string   `json:"id"`
	Issuer                  string   `json:"issuer"`
	Live                    bool     `json:"live"`
	Subject                 string   `json:"subject"`
	SubjectAlternativeNames []string `json:"subjectAlternativeNames"`
	ValidFromTime           string   `json:"validFromTime"`
}
type certificatePatch struct {
	Active bool `json:"active"`
}

var testCerts = map[string]certificate{}

// Mocking the AIC service for testing
func certificate_MockHttpServer() *httptest.Server {
	return httptest.NewTLSServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		var out []byte
		switch r.Method {
		case http.MethodPost:
			var inputCert certificate
			err := json.NewDecoder(r.Body).Decode(&inputCert)
			if err != nil {
				http.Error(w, err.Error(), http.StatusBadRequest)
				return
			}
			inputCert.ExpireTime = "2029-01-01T00:00:00Z"
			inputCert.Id = certificateId
			inputCert.Issuer = "cn=example"
			inputCert.Live = false
			inputCert.Subject = "cn=subject"
			inputCert.SubjectAlternativeNames = []string{"cn=altsubject"}
			inputCert.ValidFromTime = "2024-01-01T00:00:00Z"
			testCerts[certificateId] = inputCert
			out, _ = json.Marshal(inputCert)
		case http.MethodGet:
			certId := strings.Split(r.URL.String(), "/")[3]
			storedCert, ok := testCerts[certId]
			if !ok {
				http.Error(w, "cert not found", http.StatusNotFound)
				return
			}
			out, _ = json.Marshal(storedCert)
		case http.MethodPatch:
			certId := strings.Split(r.URL.String(), "/")[3]
			storedCert, ok := testCerts[certId]
			if !ok {
				http.Error(w, "cert not found", http.StatusNotFound)
				return
			}
			var certPatch certificatePatch
			err := json.NewDecoder(r.Body).Decode(&certPatch)
			if err != nil {
				http.Error(w, err.Error(), http.StatusBadRequest)
				return
			}
			storedCert.Active = certPatch.Active
			testCerts[certificateId] = storedCert
			out, _ = json.Marshal(storedCert)
		case http.MethodDelete:
			certId := strings.Split(r.URL.String(), "/")[3]
			storedCert, ok := testCerts[certId]
			if !ok {
				http.Error(w, "cert not found", http.StatusNotFound)
				return
			}
			delete(testCerts, certId)
			out, _ = json.Marshal(storedCert)
		}
		w.Header().Set("Content-Type", "application/json")
		w.Header().Set("Content-API-Version", "1.0")
		w.WriteHeader(http.StatusOK)
		w.Write(out)
	}))
}
