// Copyright Â© 2025 Ping Identity Corporation

// Code generated by ping-terraform-plugin-framework-generator

package secrets

import (
	"context"
	"regexp"
	"time"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	client "github.com/pingidentity/identitycloud-go-client/identitycloud"
	"github.com/pingidentity/terraform-provider-identitycloud/internal/auth"
	"github.com/pingidentity/terraform-provider-identitycloud/internal/providererror"
	internaltypes "github.com/pingidentity/terraform-provider-identitycloud/internal/types"
)

var (
	_ datasource.DataSource              = &secretVersionsDataSource{}
	_ datasource.DataSourceWithConfigure = &secretVersionsDataSource{}
)

func SecretVersionsDataSource() datasource.DataSource {
	return &secretVersionsDataSource{}
}

type secretVersionsDataSource struct {
	apiClient                 *client.APIClient
	accessToken               *string
	serviceAccountTokenSource *client.ServiceAccountTokenSource
}

func (r *secretVersionsDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_secret_versions"
}

func (r *secretVersionsDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	resourceConfig, ok := req.ProviderData.(internaltypes.ResourceConfiguration)
	if !ok {
		resp.Diagnostics.AddError(providererror.InternalProviderError, "Invalid ProviderData when configuring resource. Please report this error in the provider's issue tracker.")
		return
	}
	r.apiClient = resourceConfig.ApiClient
	r.accessToken = resourceConfig.AccessToken
	r.serviceAccountTokenSource = resourceConfig.ServiceAccountConfig
}

type secretVersionsDataSourceModel struct {
	SecretId       types.String `tfsdk:"secret_id"`
	SecretVersions types.Set    `tfsdk:"secret_versions"`
}

func (r *secretVersionsDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Data source to retrieve the versions of a secret.",
		Attributes: map[string]schema.Attribute{
			"secret_id": schema.StringAttribute{
				Required:    true,
				Description: "ID of the secret",
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^esv-[a-z0-9_-]{1,124}$"), ""),
				},
			},
			"secret_versions": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"create_date": schema.StringAttribute{
							Computed: true,
						},
						"loaded": schema.BoolAttribute{
							Computed: true,
						},
						"status": schema.StringAttribute{
							Computed: true,
						},
						"version": schema.StringAttribute{
							Computed: true,
						},
					},
				},
				Computed: true,
			},
		},
	}
}

func (state *secretVersionsDataSourceModel) readClientResponse(response []client.EsvSecretVersionResponse) diag.Diagnostics {
	var respDiags, diags diag.Diagnostics
	// secret_versions
	secretVersionsAttrTypes := map[string]attr.Type{
		"create_date": types.StringType,
		"loaded":      types.BoolType,
		"status":      types.StringType,
		"version":     types.StringType,
	}
	secretVersionsElementType := types.ObjectType{AttrTypes: secretVersionsAttrTypes}
	var secretVersionsValues []attr.Value
	for _, secretVersionsResponseValue := range response {
		secretVersionsValue, diags := types.ObjectValue(secretVersionsAttrTypes, map[string]attr.Value{
			"create_date": types.StringValue(secretVersionsResponseValue.CreateDate.Format(time.RFC3339)),
			"loaded":      types.BoolValue(secretVersionsResponseValue.Loaded),
			"status":      types.StringValue(secretVersionsResponseValue.Status),
			"version":     types.StringValue(secretVersionsResponseValue.Version),
		})
		respDiags.Append(diags...)
		secretVersionsValues = append(secretVersionsValues, secretVersionsValue)
	}
	secretVersionsValue, diags := types.SetValue(secretVersionsElementType, secretVersionsValues)
	respDiags.Append(diags...)

	state.SecretVersions = secretVersionsValue
	return respDiags
}

func (r *secretVersionsDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data secretVersionsDataSourceModel

	// Read Terraform config data into the model
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Read API call logic
	responseData, httpResp, err := r.apiClient.SecretsAPI.GetSecretVersions(auth.AuthContext(ctx, r.accessToken, r.serviceAccountTokenSource), data.SecretId.ValueString()).Execute()
	if err != nil {
		providererror.ReportHttpError(ctx, &resp.Diagnostics, "An error occurred while reading the versions of the secret", err, httpResp)
		return
	}

	// Read response into the model
	resp.Diagnostics.Append(data.readClientResponse(responseData)...)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
